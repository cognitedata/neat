from turtle import pd
import numpy as np
from rdflib import OWL, Graph

from cognite.neat.utils.utils import remove_namespace


def parse_owl_classes(graph: Graph, make_compliant: bool = False) -> pd.DataFrame:
    """Parse owl classes from graph to pandas dataframe.

    Args:
        graph: Graph containing owl classes
        make_compliant: Flag for generating compliant classes, by default False

    Returns:
        Dataframe containing owl classes
    """

    query = """
        SELECT ?class ?name ?description ?parentClass ?deprecated ?deprecationDate
        ?replacedBy ?source ?sourceEntity ?match ?comment
        WHERE {
        ?class a owl:Class .
        OPTIONAL {?class rdfs:subClassOf ?parentClass }.
        OPTIONAL {?class rdfs:label ?name }.
        OPTIONAL {?class rdfs:comment ?description} .
        OPTIONAL {?class owl:deprecated ?deprecated} .
        FILTER (!isBlank(?class))
        FILTER (!bound(?parentClass) || !isBlank(?parentClass))
        FILTER (!bound(?name) || LANG(?name) = "" || LANGMATCHES(LANG(?name), "en"))
        FILTER (!bound(?description) || LANG(?description) = "" || LANGMATCHES(LANG(?description), "en"))
    }
    """

    # create raw dataframe

    raw_df = _parse_raw_dataframe(list(graph.query(query)))
    if raw_df.empty:
        return pd.concat([raw_df, pd.DataFrame([len(raw_df) * [""]])], ignore_index=True)

    # group values and clean up
    processed_df = _clean_up_classes(raw_df)

    # make compliant if needed

    if make_compliant:
        return make_classes_compliant(processed_df)

    return processed_df


def make_classes_compliant(df: pd.DataFrame) -> pd.DataFrame:
    df = pd.concat(
        [df, pd.DataFrame([_object_property_class(), _data_type_property_class(), _thing_class()])],
        ignore_index=True,
    )

    # Replace empty or non-string values in "Match Type" column with "exact"
    df["Match Type"] = df["Match Type"].fillna("exact")
    df["Match Type"] = df["Match Type"].apply(lambda x: "exact" if not isinstance(x, str) or len(x) == 0 else x)

    # Replace empty or non-string values in "Comment" column with a default value
    df["Comment"] = df["Comment"].fillna("Generated by NEAT")
    df["Comment"] = df["Comment"].apply(lambda x: "Generated by NEAT" if not isinstance(x, str) or len(x) == 0 else x)

    # Replace empty or non-boolean values in "Deprecated" column with False
    df["Deprecated"] = df["Deprecated"].fillna(False)
    df["Deprecated"] = df["Deprecated"].apply(lambda x: False if not isinstance(x, bool) else x)

    return df


def _clean_up_classes(df: pd.DataFrame) -> pd.DataFrame:
    clean_list = [
        {
            "Class": class_,
            "Name": group_df["Name"].unique()[0],
            "Description": "\n".join(list(group_df.Description.unique())),
            "Parent Class": ", ".join(list(group_df["Parent Class"].unique())),
            "Deprecated": group_df.Deprecated.unique()[0],
            "Deprecation Date": group_df["Deprecation Date"].unique()[0],
            "Replaced By": group_df["Replaced By"].unique()[0],
            "Source": group_df["Source"].unique()[0],
            "Source Entity Name": group_df["Name"].unique()[0],
            "Match Type": group_df["Match"].unique()[0],
            "Comment": group_df["Comment"].unique()[0],
        }
        for class_, group_df in raw_df.groupby("Class")
    ]

    df = pd.DataFrame(clean_list)

    # bring NaNs back
    df.replace("", None, inplace=True)

    return df


def _parse_raw_dataframe(query_results: list[tuple]) -> pd.DataFrame:
    df = pd.DataFrame(
        query_results,
        columns=[
            "Class",
            "Name",
            "Description",
            "Parent Class",
            "Deprecated",
            "Deprecation Date",
            "Replaced By",
            "Source",
            "Source Entity Name",
            "Match",
            "Comment",
        ],
    )
    if df.empty:
        return df

    # remove NaNs
    df.replace(np.nan, "", regex=True, inplace=True)

    df.Source = df.Class
    df.Class = df.Class.apply(lambda x: remove_namespace(x))
    df["Source Entity Name"] = df.Class
    df["Match"] = len(df) * ["exact"]
    df["Parent Class"] = df["Parent Class"].apply(lambda x: remove_namespace(x))

    return df


def _object_property_class() -> dict:
    return {
        "Class": "ObjectPropertyContainer",
        "Name": None,
        "Description": "The class of object properties.",
        "Parent Class": None,
        "Deprecated": False,
        "Deprecation Date": None,
        "Replaced By": None,
        "Source": OWL.ObjectProperty,
        "Source Entity Name": "ObjectProperty",
        "Match Type": "exact",
        "Comment": "Imported from OWL",
    }


def _data_type_property_class() -> dict:
    return {
        "Class": "DatatypePropertyContainer",
        "Name": None,
        "Description": "The class of data properties.",
        "Parent Class": None,
        "Deprecated": False,
        "Deprecation Date": None,
        "Replaced By": None,
        "Source": OWL.DatatypeProperty,
        "Source Entity Name": "DatatypeProperty",
        "Match Type": "exact",
        "Comment": "Imported from OWL",
    }


def _thing_class() -> dict:
    return {
        "Class": "ThingContainer",
        "Name": None,
        "Description": "The class of holding class individuals.",
        "Parent Class": None,
        "Deprecated": False,
        "Deprecation Date": None,
        "Replaced By": None,
        "Source": OWL.Thing,
        "Source Entity Name": "Thing",
        "Match Type": "exact",
        "Comment": "Imported from OWL",
    }
